<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESN Regression Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: "class",
        theme: {
          extend: {
            colors: {
              brand: {
                50: "#eff6ff",
                100: "#dbeafe",
                500: "#3b82f6",
                600: "#2563eb",
                700: "#1d4ed8",
              },
              surface: { light: "#ffffff", dark: "#1e293b" },
            },
            animation: {
              "fade-in": "fadeIn 0.2s ease-out",
              "slide-up": "slideUp 0.3s ease-out",
              "slide-in-right": "slideInRight 0.3s ease-out",
              "pulse-subtle": "pulseSubtle 2s infinite",
            },
            keyframes: {
              fadeIn: {
                "0%": { opacity: "0" },
                "100%": { opacity: "1" },
              },
              slideUp: {
                "0%": { opacity: "0", transform: "translateY(10px)" },
                "100%": { opacity: "1", transform: "translateY(0)" },
              },
              slideInRight: {
                "0%": { transform: "translateX(100%)" },
                "100%": { transform: "translateX(0)" },
              },
              pulseSubtle: {
                "0%, 100%": { opacity: "1" },
                "50%": { opacity: "0.7" },
              },
            },
          },
        },
      };
    </script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");
      body {
        font-family: "Inter", system-ui, sans-serif;
      }
      .scrollbar-thin::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      .scrollbar-thin::-webkit-scrollbar-track {
        background: transparent;
      }
      .scrollbar-thin::-webkit-scrollbar-thumb {
        background: rgba(100, 116, 139, 0.3);
        border-radius: 3px;
      }
      .scrollbar-thin::-webkit-scrollbar-thumb:hover {
        background: rgba(100, 116, 139, 0.5);
      }
      input[type="range"] {
        -webkit-appearance: none;
        background: transparent;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        height: 16px;
        width: 16px;
        border-radius: 50%;
        background: #3b82f6;
        cursor: pointer;
        margin-top: -6px;
      }
      input[type="range"]::-webkit-slider-runnable-track {
        width: 100%;
        height: 4px;
        background: #e2e8f0;
        border-radius: 2px;
      }
      .dark input[type="range"]::-webkit-slider-runnable-track {
        background: #475569;
      }
      .skeleton {
        background: linear-gradient(
          90deg,
          #f1f5f9 25%,
          #e2e8f0 50%,
          #f1f5f9 75%
        );
        background-size: 200% 100%;
        animation: shimmer 1.5s infinite;
      }
      .dark .skeleton {
        background: linear-gradient(
          90deg,
          #334155 25%,
          #475569 50%,
          #334155 75%
        );
        background-size: 200% 100%;
      }
      @keyframes shimmer {
        0% {
          background-position: 200% 0;
        }
        100% {
          background-position: -200% 0;
        }
      }
      .modal-backdrop {
        backdrop-filter: blur(4px);
      }
      .tooltip-arrow {
        clip-path: polygon(0 0, 100% 0, 50% 100%);
      }
    </style>
  </head>
  <body
    class="bg-slate-50 dark:bg-slate-900 text-slate-900 dark:text-slate-100 min-h-screen transition-colors duration-200"
  >
    <div id="app"></div>

    <script>
      (function () {
        "use strict";

        const VERSION = "1.0.0";
        const DEFAULT_MODULE_URL =
          "https://cdn.esm.sh/jsr/@hviana/multivariate-regression";
        const COLORS = [
          "#3B82F6",
          "#10B981",
          "#F59E0B",
          "#EF4444",
          "#8B5CF6",
          "#EC4899",
          "#06B6D4",
          "#84CC16",
        ];

        const PRESETS = {
          startHere: {
            name: "Start Here",
            desc: "Balanced defaults for most use cases",
            config: {
              reservoirSize: 256,
              maxSequenceLength: 64,
              spectralRadius: 0.9,
              leakRate: 0.3,
              inputScale: 1.0,
              biasScale: 0.1,
              reservoirSparsity: 0.9,
              inputSparsity: 0.0,
              activation: "tanh",
              useInputInReadout: true,
              useBiasInReadout: true,
              rlsLambda: 0.999,
              rlsDelta: 1.0,
              epsilon: 1e-8,
              l2Lambda: 0.0001,
              gradientClipNorm: 1.0,
              normalizationEpsilon: 1e-8,
              normalizationWarmup: 10,
              outlierThreshold: 3.0,
              outlierMinWeight: 0.1,
              residualWindowSize: 100,
              uncertaintyMultiplier: 1.96,
              weightInitScale: 0.1,
              seed: 42,
              rollforwardMode: "holdLastX",
            },
          },
          fastLight: {
            name: "Fast/Light",
            desc: "Quick training, lower capacity",
            config: {
              reservoirSize: 64,
              maxSequenceLength: 32,
              spectralRadius: 0.8,
              leakRate: 0.5,
              inputScale: 1.0,
              biasScale: 0.1,
              reservoirSparsity: 0.95,
              inputSparsity: 0.0,
              activation: "tanh",
              useInputInReadout: true,
              useBiasInReadout: true,
              rlsLambda: 0.99,
              rlsDelta: 1.0,
              epsilon: 1e-8,
              l2Lambda: 0.001,
              gradientClipNorm: 1.0,
              normalizationEpsilon: 1e-8,
              normalizationWarmup: 5,
              outlierThreshold: 3.0,
              outlierMinWeight: 0.1,
              residualWindowSize: 50,
              uncertaintyMultiplier: 1.96,
              weightInitScale: 0.1,
              seed: 42,
              rollforwardMode: "holdLastX",
            },
          },
          balanced: {
            name: "Balanced",
            desc: "Good balance of speed and accuracy",
            config: {
              reservoirSize: 256,
              maxSequenceLength: 64,
              spectralRadius: 0.9,
              leakRate: 0.3,
              inputScale: 1.0,
              biasScale: 0.1,
              reservoirSparsity: 0.9,
              inputSparsity: 0.0,
              activation: "tanh",
              useInputInReadout: true,
              useBiasInReadout: true,
              rlsLambda: 0.999,
              rlsDelta: 1.0,
              epsilon: 1e-8,
              l2Lambda: 0.0001,
              gradientClipNorm: 1.0,
              normalizationEpsilon: 1e-8,
              normalizationWarmup: 10,
              outlierThreshold: 3.0,
              outlierMinWeight: 0.1,
              residualWindowSize: 100,
              uncertaintyMultiplier: 1.96,
              weightInitScale: 0.1,
              seed: 42,
              rollforwardMode: "holdLastX",
            },
          },
          accurateStable: {
            name: "Accurate/Stable",
            desc: "Higher capacity, more stable",
            config: {
              reservoirSize: 512,
              maxSequenceLength: 128,
              spectralRadius: 0.95,
              leakRate: 0.2,
              inputScale: 1.0,
              biasScale: 0.1,
              reservoirSparsity: 0.85,
              inputSparsity: 0.0,
              activation: "tanh",
              useInputInReadout: true,
              useBiasInReadout: true,
              rlsLambda: 0.9995,
              rlsDelta: 1.0,
              epsilon: 1e-8,
              l2Lambda: 0.0001,
              gradientClipNorm: 0.5,
              normalizationEpsilon: 1e-8,
              normalizationWarmup: 20,
              outlierThreshold: 3.0,
              outlierMinWeight: 0.1,
              residualWindowSize: 150,
              uncertaintyMultiplier: 1.96,
              weightInitScale: 0.1,
              seed: 42,
              rollforwardMode: "holdLastX",
            },
          },
          adaptiveDrift: {
            name: "Adaptive/Drift",
            desc: "For non-stationary data",
            config: {
              reservoirSize: 256,
              maxSequenceLength: 64,
              spectralRadius: 0.85,
              leakRate: 0.5,
              inputScale: 1.0,
              biasScale: 0.1,
              reservoirSparsity: 0.9,
              inputSparsity: 0.0,
              activation: "tanh",
              useInputInReadout: true,
              useBiasInReadout: true,
              rlsLambda: 0.97,
              rlsDelta: 1.0,
              epsilon: 1e-8,
              l2Lambda: 0.001,
              gradientClipNorm: 1.0,
              normalizationEpsilon: 1e-8,
              normalizationWarmup: 10,
              outlierThreshold: 2.5,
              outlierMinWeight: 0.1,
              residualWindowSize: 50,
              uncertaintyMultiplier: 1.96,
              weightInitScale: 0.1,
              seed: 42,
              rollforwardMode: "holdLastX",
            },
          },
          noisyRobust: {
            name: "Noisy/Robust",
            desc: "Handles noisy data well",
            config: {
              reservoirSize: 256,
              maxSequenceLength: 64,
              spectralRadius: 0.9,
              leakRate: 0.2,
              inputScale: 0.8,
              biasScale: 0.1,
              reservoirSparsity: 0.9,
              inputSparsity: 0.0,
              activation: "tanh",
              useInputInReadout: true,
              useBiasInReadout: true,
              rlsLambda: 0.999,
              rlsDelta: 1.0,
              epsilon: 1e-8,
              l2Lambda: 0.01,
              gradientClipNorm: 0.5,
              normalizationEpsilon: 1e-8,
              normalizationWarmup: 20,
              outlierThreshold: 2.0,
              outlierMinWeight: 0.05,
              residualWindowSize: 100,
              uncertaintyMultiplier: 2.58,
              weightInitScale: 0.1,
              seed: 42,
              rollforwardMode: "holdLastX",
            },
          },
        };

        const PARAM_DOCS = {
          reservoirSize: {
            title: "Reservoir Size",
            desc: "Number of neurons in the reservoir",
            range: "32-1024",
            advice:
              "Start with 128-256. Increase for complex patterns.",
            failModes:
              "Too small: underfitting. Too large: slow, overfitting.",
          },
          maxSequenceLength: {
            title: "Max Sequence Length",
            desc: "Maximum temporal context window",
            range: "16-512",
            advice: "Should cover your longest patterns",
            failModes:
              "Too short: loses long patterns. Too long: memory overhead.",
          },
          spectralRadius: {
            title: "Spectral Radius",
            desc: "Controls memory/stability trade-off",
            range: "0.1-0.99",
            advice: "0.9 is safe. Higher for long-term dependencies.",
            failModes: "≥1.0: instability. Too low: short memory.",
          },
          leakRate: {
            title: "Leak Rate",
            desc: "Temporal smoothing factor",
            range: "0.1-1.0",
            advice: "Lower for noisy data, higher for fast changes",
            failModes: "Too low: sluggish. Too high: noise sensitive.",
          },
          inputScale: {
            title: "Input Scale",
            desc: "Scales input before reservoir",
            range: "0.1-3.0",
            advice: "Usually 1.0 with normalization",
            failModes: "Too high: saturation. Too low: weak signal.",
          },
          biasScale: {
            title: "Bias Scale",
            desc: "Random bias magnitude",
            range: "0.0-0.5",
            advice: "Usually 0.1",
            failModes: "Too high: noise. Too low: symmetry issues.",
          },
          reservoirSparsity: {
            title: "Reservoir Sparsity",
            desc: "Fraction of zero connections",
            range: "0.0-0.99",
            advice: "0.9 is common (10% connected)",
            failModes: "Too dense: slow. Too sparse: poor dynamics.",
          },
          inputSparsity: {
            title: "Input Sparsity",
            desc: "Sparsity of input connections",
            range: "0.0-0.9",
            advice: "0 for dense, higher for feature selection",
            failModes: "Too high: information loss.",
          },
          activation: {
            title: "Activation Function",
            desc: "Nonlinearity type",
            range: "tanh, relu",
            advice: "tanh for bounded, relu for positive",
            failModes: "relu: unbounded outputs.",
          },
          rlsLambda: {
            title: "RLS Lambda",
            desc: "Forgetting factor",
            range: "0.9-0.9999",
            advice: "Higher for stationary, lower for drift",
            failModes: "Too low: instability. Too high: slow adapt.",
          },
          rlsDelta: {
            title: "RLS Delta",
            desc: "Initial P matrix scale",
            range: "0.01-100",
            advice: "Higher for faster initial learning",
            failModes: "Too high: large initial swings.",
          },
          l2Lambda: {
            title: "L2 Regularization",
            desc: "Weight decay",
            range: "0-0.1",
            advice: "Increase if overfitting",
            failModes: "Too high: underfitting.",
          },
          outlierThreshold: {
            title: "Outlier Threshold",
            desc: "Z-score for outlier detection",
            range: "2.0-5.0",
            advice: "3.0 is standard (0.3% outliers)",
            failModes: "Too low: loses data. Too high: keeps outliers.",
          },
          uncertaintyMultiplier: {
            title: "Uncertainty Multiplier",
            desc: "Confidence interval width",
            range: "1.0-3.0",
            advice: "1.96 for 95% CI",
            failModes: "Too low: overconfident. Too high: wide bands.",
          },
          seed: {
            title: "Random Seed",
            desc: "For reproducibility",
            range: "Any integer",
            advice: "Same seed = same results",
            failModes: "N/A",
          },
          rollforwardMode: {
            title: "Rollforward Mode",
            desc: "Multi-step prediction strategy",
            range: "holdLastX, autoregressive",
            advice: "holdLastX is safer",
            failModes: "autoregressive requires nFeatures=nTargets.",
          },
        };

        let state = {
          theme: localStorage.getItem("esn_theme") || "light",
          moduleUrl: localStorage.getItem("esn_moduleUrl") ||
            DEFAULT_MODULE_URL,
          modelReady: false,
          modelConfig: null,
          modelSummary: null,
          datasetInfo: null,
          predictions: null,
          trainingStats: null,
          logs: [],
          toasts: [],
          activeModal: null,
          viewMode: localStorage.getItem("esn_viewMode") || "focus",
          selectedDim: 0,
          futureSteps: 10,
          isLoading: false,
          loadingMessage: "",
          progress: null,
          menuOpen: false,
          workerReady: false,
          cancelRequested: false,
          performanceMode:
            localStorage.getItem("esn_perfMode") === "true",
          zoom: { x: 0, y: 0, scale: 1 },
        };

        let worker = null;
        let pendingRequests = {};
        let requestIdCounter = 0;

        function createWorker() {
          const workerCode = `
let ESNRegression = null;
let model = null;
let dataset = { x: [], y: [] };
let moduleLoaded = false;
let cancelTokens = new Set();

async function loadModule(url) {
  try {
    const mod = await import(url);
    ESNRegression = mod.ESNRegression || mod.default?.ESNRegression || mod.default;
    if (!ESNRegression) throw new Error('ESNRegression not found in module');
    moduleLoaded = true;
    return { success: true };
  } catch (e1) {
    try {
      const response = await fetch(url);
      let text = await response.text();
      const match = text.match(/export\\s*{\\s*([^}]+)\\s*}/);
      if (match) {
        const exports = match[1].split(',').map(s => s.trim().split(/\\s+as\\s+/)[0]);
        text = text.replace(/export\\s*{[^}]+}/, '');
        text = text.replace(/export\\s+(class|function|const|let|var)/g, '$1');
        const fn = new Function('exports', text + ';return{' + exports.join(',') + '}');
        const result = fn({});
        ESNRegression = result.ESNRegression;
        if (!ESNRegression) throw new Error('ESNRegression not found after eval');
        moduleLoaded = true;
        return { success: true };
      }
      throw new Error('Could not parse module');
    } catch (e2) {
      return { success: false, error: e1.message + ' / Fallback: ' + e2.message };
    }
  }
}

function validateData(data, requireY = true) {
  if (!data || typeof data !== 'object') return { valid: false, error: 'Data must be an object' };
  let xCoords = [], yCoords = [];
  if (data.xCoordinates && data.yCoordinates) {
    xCoords = data.xCoordinates;
    yCoords = data.yCoordinates;
  } else if (data.samples && Array.isArray(data.samples)) {
    for (const s of data.samples) {
      if (!s.x || !Array.isArray(s.x)) return { valid: false, error: 'Sample missing x array' };
      xCoords.push(s.x);
      if (requireY) {
        if (!s.y || !Array.isArray(s.y)) return { valid: false, error: 'Sample missing y array' };
        yCoords.push(s.y);
      }
    }
  } else if (data.x && Array.isArray(data.x)) {
    xCoords = [data.x];
    if (requireY) {
      if (!data.y || !Array.isArray(data.y)) return { valid: false, error: 'Missing y array' };
      yCoords = [data.y];
    }
  } else {
    return { valid: false, error: 'Unrecognized data format' };
  }
  if (xCoords.length === 0) return { valid: false, error: 'No samples found' };
  const nFeatures = xCoords[0].length;
  const nTargets = requireY ? yCoords[0].length : 0;
  for (let i = 0; i < xCoords.length; i++) {
    if (!Array.isArray(xCoords[i])) return { valid: false, error: 'x[' + i + '] is not an array' };
    if (xCoords[i].length !== nFeatures) return { valid: false, error: 'Inconsistent feature count at sample ' + i };
    for (let j = 0; j < xCoords[i].length; j++) {
      if (typeof xCoords[i][j] !== 'number' || isNaN(xCoords[i][j])) return { valid: false, error: 'x[' + i + '][' + j + '] is not a valid number' };
    }
    if (requireY) {
      if (!Array.isArray(yCoords[i])) return { valid: false, error: 'y[' + i + '] is not an array' };
      if (yCoords[i].length !== nTargets) return { valid: false, error: 'Inconsistent target count at sample ' + i };
      for (let j = 0; j < yCoords[i].length; j++) {
        if (typeof yCoords[i][j] !== 'number' || isNaN(yCoords[i][j])) return { valid: false, error: 'y[' + i + '][' + j + '] is not a valid number' };
      }
    }
  }
  return { valid: true, xCoordinates: xCoords, yCoordinates: yCoords, nFeatures, nTargets, sampleCount: xCoords.length };
}

self.onmessage = async function(e) {
  const { requestId, type, payload } = e.data;
  
  const respond = (result) => self.postMessage({ requestId, type: 'response', result });
  const error = (msg) => self.postMessage({ requestId, type: 'error', error: msg });
  const progress = (data) => self.postMessage({ requestId, type: 'progress', ...data });

  try {
    switch(type) {
      case 'init': {
        const res = await loadModule(payload.moduleUrl);
        if (!res.success) return error(res.error);
        respond({ ready: true });
        break;
      }
      
      case 'create': {
        if (!moduleLoaded) return error('Module not loaded');
        model = new ESNRegression(payload.config);
        dataset = { x: [], y: [] };
        respond({ created: true, config: payload.config });
        break;
      }
      
      case 'fitOnline': {
        if (!model) return error('No model created');
        const v = validateData(payload.data);
        if (!v.valid) return error(v.error);
        const batchSize = v.sampleCount;
        let result = null;
        cancelTokens.add(requestId);
        for (let i = 0; i < batchSize; i++) {
          if (!cancelTokens.has(requestId)) {
            respond({ cancelled: true, processed: i });
            return;
          }
          result = model.fitOnline({ xCoordinates: [v.xCoordinates[i]], yCoordinates: [v.yCoordinates[i]] });
          dataset.x.push(v.xCoordinates[i]);
          dataset.y.push(v.yCoordinates[i]);
          if (batchSize > 10 && i % Math.max(1, Math.floor(batchSize / 100)) === 0) {
            progress({ processed: i + 1, total: batchSize, percent: Math.round(((i + 1) / batchSize) * 100), stage: 'training' });
          }
        }
        cancelTokens.delete(requestId);
        respond({ result, datasetSize: dataset.x.length, nFeatures: v.nFeatures, nTargets: v.nTargets });
        break;
      }
      
      case 'predict': {
        if (!model) return error('No model created');
        const futureSteps = payload.futureSteps || 10;
        const pred = model.predict(futureSteps);
        respond({ predictions: pred.predictions, lowerBounds: pred.lowerBounds, upperBounds: pred.upperBounds, confidence: pred.confidence });
        break;
      }
      
      case 'getSummary': {
        if (!model) return error('No model created');
        const summary = model.getModelSummary();
        respond({ summary, datasetSize: dataset.x.length });
        break;
      }
      
      case 'save': {
        if (!model) return error('No model created');
        const modelState = model.save();
        const summary = model.getModelSummary();
        respond({ modelState, meta: { config: summary, nFeatures: summary.nFeatures, nTargets: summary.nTargets, createdAt: new Date().toISOString(), appVersion: '${VERSION}' }});
        break;
      }
      
      case 'load': {
        if (!moduleLoaded) return error('Module not loaded');
        let data = payload.data;
        let config = null;
        if (typeof data === 'string') {
          try {
            const parsed = JSON.parse(data);
            if (parsed.modelState) {
              data = parsed.modelState;
              config = parsed.meta?.config;
            }
          } catch { }
        } else if (data.modelState) {
          config = data.meta?.config;
          data = data.modelState;
        }
        model = new ESNRegression();
        model.load(typeof data === 'string' ? data : JSON.stringify(data));
        dataset = { x: [], y: [] };
        const summary = model.getModelSummary();
        respond({ loaded: true, summary, config });
        break;
      }
      
      case 'reset': {
        if (model) model.reset();
        dataset = { x: [], y: [] };
        respond({ reset: true });
        break;
      }
      
      case 'cancel': {
        cancelTokens.delete(payload.targetRequestId);
        respond({ cancelled: true });
        break;
      }
      
      case 'getDataset': {
        respond({ x: dataset.x, y: dataset.y, size: dataset.x.length });
        break;
      }
      
      case 'validateData': {
        const v = validateData(payload.data);
        respond(v);
        break;
      }
      
      default:
        error('Unknown command: ' + type);
    }
  } catch (err) {
    error(err.message || String(err));
  }
};
`;

          const blob = new Blob([workerCode], {
            type: "application/javascript",
          });
          const url = URL.createObjectURL(blob);
          worker = new Worker(url, { type: "module" });

          worker.onmessage = (e) => {
            const { requestId, type, result, error: err, ...rest } =
              e.data;
            const pending = pendingRequests[requestId];
            if (!pending) return;

            if (type === "progress") {
              if (pending.onProgress) pending.onProgress(rest);
              return;
            }

            delete pendingRequests[requestId];
            if (type === "error") {
              pending.reject(new Error(err));
            } else {
              pending.resolve(result);
            }
          };

          worker.onerror = (e) => {
            log("error", "Worker error", e.message);
          };
        }

        function sendToWorker(type, payload, onProgress) {
          return new Promise((resolve, reject) => {
            const requestId = ++requestIdCounter;
            pendingRequests[requestId] = {
              resolve,
              reject,
              onProgress,
            };
            worker.postMessage({ requestId, type, payload });
          });
        }

        async function initWorker() {
          try {
            setState({
              isLoading: true,
              loadingMessage: "Initializing worker...",
            });
            await sendToWorker("init", { moduleUrl: state.moduleUrl });
            setState({ workerReady: true });
            log(
              "success",
              "Worker initialized",
              "Module loaded from " + state.moduleUrl,
            );
          } catch (e) {
            log("error", "Worker init failed", e.message);
            toast("Failed to initialize worker: " + e.message, "error");
          } finally {
            setState({ isLoading: false });
          }
        }

        function setState(updates) {
          Object.assign(state, updates);
          render();
        }

        function log(level, action, details = "") {
          state.logs.unshift({
            id: Date.now(),
            timestamp: new Date(),
            level,
            action,
            details,
          });
          if (state.logs.length > 500) state.logs.pop();
          render();
        }

        function toast(message, type = "info", duration = 4000) {
          const id = Date.now();
          state.toasts.push({ id, message, type });
          render();
          setTimeout(() => {
            state.toasts = state.toasts.filter((t) => t.id !== id);
            render();
          }, duration);
        }

        function applyTheme() {
          if (state.theme === "dark") {
            document.documentElement.classList.add("dark");
          } else {
            document.documentElement.classList.remove("dark");
          }
          localStorage.setItem("esn_theme", state.theme);
        }

        function toggleTheme() {
          setState({
            theme: state.theme === "dark" ? "light" : "dark",
          });
          applyTheme();
        }

        async function createModel(config) {
          try {
            setState({
              isLoading: true,
              loadingMessage: "Creating model...",
            });
            await sendToWorker("create", { config });
            setState({
              modelReady: true,
              modelConfig: config,
              predictions: null,
              datasetInfo: null,
              trainingStats: null,
            });
            log(
              "success",
              "Model created",
              "Reservoir: " + config.reservoirSize +
                ", Spectral radius: " + config.spectralRadius,
            );
            toast("Model created successfully", "success");
            await refreshSummary();
          } catch (e) {
            log("error", "Create model failed", e.message);
            toast("Failed to create model: " + e.message, "error");
          } finally {
            setState({ isLoading: false, activeModal: null });
          }
        }

        async function trainData(data) {
          try {
            setState({
              isLoading: true,
              loadingMessage: "Training...",
              progress: { processed: 0, total: 0, percent: 0 },
            });
            const result = await sendToWorker(
              "fitOnline",
              { data },
              (p) => {
                setState({ progress: p });
              },
            );
            if (result.cancelled) {
              log(
                "warning",
                "Training cancelled",
                "Processed " + result.processed + " samples",
              );
              toast("Training cancelled", "warning");
            } else {
              setState({
                trainingStats: result.result,
                datasetInfo: {
                  size: result.datasetSize,
                  nFeatures: result.nFeatures,
                  nTargets: result.nTargets,
                },
              });
              log(
                "success",
                "Training complete",
                "Processed: " + result.datasetSize + ", Loss: " +
                  (result.result?.averageLoss?.toFixed(6) || "N/A"),
              );
              toast(
                "Training complete: " + result.datasetSize + " samples",
                "success",
              );
            }
            await refreshSummary();
          } catch (e) {
            log("error", "Training failed", e.message);
            toast("Training failed: " + e.message, "error");
          } finally {
            setState({
              isLoading: false,
              progress: null,
              activeModal: null,
            });
          }
        }

        async function runPrediction(futureSteps) {
          try {
            setState({
              isLoading: true,
              loadingMessage: "Predicting...",
            });
            const result = await sendToWorker("predict", {
              futureSteps,
            });
            setState({ predictions: result, futureSteps });
            log(
              "success",
              "Prediction complete",
              futureSteps + " steps, confidence: " +
                (result.confidence * 100).toFixed(1) + "%",
            );
            toast("Prediction complete", "success");
          } catch (e) {
            log("error", "Prediction failed", e.message);
            toast("Prediction failed: " + e.message, "error");
          } finally {
            setState({ isLoading: false });
          }
        }

        async function refreshSummary() {
          try {
            const result = await sendToWorker("getSummary", {});
            setState({
              modelSummary: result.summary,
              datasetInfo: state.datasetInfo
                ? { ...state.datasetInfo, size: result.datasetSize }
                : {
                  size: result.datasetSize,
                  nFeatures: result.summary.nFeatures,
                  nTargets: result.summary.nTargets,
                },
            });
          } catch (e) {
            log("error", "Get summary failed", e.message);
          }
        }

        async function saveModel() {
          try {
            const result = await sendToWorker("save", {});
            const blob = new Blob([
              JSON.stringify(
                { modelState: result.modelState, meta: result.meta },
                null,
                2,
              ),
            ], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "esn-model-" +
              new Date().toISOString().slice(0, 10) + ".json";
            a.click();
            URL.revokeObjectURL(url);
            log("success", "Model saved", "Downloaded to file");
            toast("Model saved to file", "success");
          } catch (e) {
            log("error", "Save failed", e.message);
            toast("Save failed: " + e.message, "error");
          }
        }

        async function loadModelFile(file) {
          try {
            setState({
              isLoading: true,
              loadingMessage: "Loading model...",
            });
            const text = await file.text();
            await sendToWorker("load", { data: text });
            await refreshSummary();
            setState({ modelReady: true, predictions: null });
            log("success", "Model loaded", "From file: " + file.name);
            toast("Model loaded successfully", "success");
          } catch (e) {
            log("error", "Load failed", e.message);
            toast("Load failed: " + e.message, "error");
          } finally {
            setState({ isLoading: false, activeModal: null });
          }
        }

        async function resetModel() {
          try {
            await sendToWorker("reset", {});
            setState({
              predictions: null,
              trainingStats: null,
              datasetInfo: null,
            });
            await refreshSummary();
            log("info", "Model reset", "Weights and data cleared");
            toast("Model reset", "info");
          } catch (e) {
            log("error", "Reset failed", e.message);
          }
        }

        async function validateDataInput(jsonText) {
          try {
            const data = JSON.parse(jsonText);
            return await sendToWorker("validateData", { data });
          } catch (e) {
            return {
              valid: false,
              error: "Invalid JSON: " + e.message,
            };
          }
        }

        function seededRandom(seed) {
          let s = seed;
          return () => {
            s = (s * 1103515245 + 12345) & 0x7fffffff;
            return s / 0x7fffffff;
          };
        }

        function generateSyntheticData(params) {
          const {
            seed,
            nFeatures,
            nTargets,
            nSamples,
            difficulty,
            noise,
            outlierRate,
          } = params;
          const rng = seededRandom(seed);
          const x = [], y = [];

          const coeffs = [];
          for (let t = 0; t < nTargets; t++) {
            coeffs[t] = [];
            for (let f = 0; f < nFeatures; f++) {
              coeffs[t][f] = (rng() - 0.5) * 2 * difficulty;
            }
          }

          for (let i = 0; i < nSamples; i++) {
            const xi = [];
            for (let f = 0; f < nFeatures; f++) {
              xi.push(Math.sin(i * 0.1 + f) + rng() * 0.5);
            }
            x.push(xi);

            const yi = [];
            for (let t = 0; t < nTargets; t++) {
              let val = 0;
              for (let f = 0; f < nFeatures; f++) {
                val += coeffs[t][f] * xi[f];
                if (difficulty > 0.5) {
                  val += coeffs[t][f] * Math.sin(xi[f] * 2);
                }
              }
              val += (rng() - 0.5) * noise * 2;
              if (rng() < outlierRate) val += (rng() - 0.5) * 10;
              yi.push(val);
            }
            y.push(yi);
          }

          return {
            xCoordinates: x,
            yCoordinates: y,
            description:
              `Synthetic data: ${nFeatures}D→${nTargets}D, ${nSamples} samples, difficulty=${difficulty}`,
          };
        }

        async function runRandomTest(params) {
          try {
            setState({
              isLoading: true,
              loadingMessage: "Generating data...",
            });
            const config = PRESETS.startHere.config;
            await createModel(config);

            const data = generateSyntheticData(params);
            setState({ loadingMessage: "Training..." });
            await trainData(data);

            setState({ loadingMessage: "Predicting..." });
            await runPrediction(20);

            setState({ viewMode: "focus", selectedDim: 0 });
            log("success", "Random test complete", data.description);
            toast("Test complete! Check the visualization", "success");
          } catch (e) {
            log("error", "Random test failed", e.message);
            toast("Test failed: " + e.message, "error");
          } finally {
            setState({ isLoading: false, activeModal: null });
          }
        }

        function cancelOperation() {
          const keys = Object.keys(pendingRequests);
          keys.forEach((k) => {
            sendToWorker("cancel", { targetRequestId: parseInt(k) });
          });
          setState({ cancelRequested: true });
        }

        function lttbDownsample(data, threshold) {
          if (data.length <= threshold) return data;
          const sampled = [data[0]];
          const bucketSize = (data.length - 2) / (threshold - 2);
          let a = 0;
          for (let i = 0; i < threshold - 2; i++) {
            const avgRangeStart = Math.floor((i + 1) * bucketSize) + 1;
            const avgRangeEnd = Math.min(
              Math.floor((i + 2) * bucketSize) + 1,
              data.length,
            );
            let avgX = 0, avgY = 0;
            for (let j = avgRangeStart; j < avgRangeEnd; j++) {
              avgX += j;
              avgY += data[j];
            }
            avgX /= avgRangeEnd - avgRangeStart;
            avgY /= avgRangeEnd - avgRangeStart;

            const rangeStart = Math.floor(i * bucketSize) + 1;
            const rangeEnd = Math.floor((i + 1) * bucketSize) + 1;
            let maxArea = -1, maxIdx = rangeStart;
            for (let j = rangeStart; j < rangeEnd; j++) {
              const area = Math.abs(
                (a - avgX) * (data[j] - data[a]) -
                  (a - j) * (avgY - data[a]),
              ) * 0.5;
              if (area > maxArea) {
                maxArea = area;
                maxIdx = j;
              }
            }
            sampled.push(data[maxIdx]);
            a = maxIdx;
          }
          sampled.push(data[data.length - 1]);
          return sampled;
        }

        function niceNumber(range, round) {
          const exp = Math.floor(Math.log10(range));
          const frac = range / Math.pow(10, exp);
          let nice;
          if (round) {
            if (frac < 1.5) nice = 1;
            else if (frac < 3) nice = 2;
            else if (frac < 7) nice = 5;
            else nice = 10;
          } else {
            if (frac <= 1) nice = 1;
            else if (frac <= 2) nice = 2;
            else if (frac <= 5) nice = 5;
            else nice = 10;
          }
          return nice * Math.pow(10, exp);
        }

        function niceTicks(min, max, count = 6) {
          const range = niceNumber(max - min, false);
          const spacing = niceNumber(range / (count - 1), true);
          const niceMin = Math.floor(min / spacing) * spacing;
          const niceMax = Math.ceil(max / spacing) * spacing;
          const ticks = [];
          for (
            let t = niceMin;
            t <= niceMax + spacing * 0.5;
            t += spacing
          ) {
            ticks.push(t);
          }
          return ticks;
        }

        function formatNumber(n, precision = 4) {
          if (Math.abs(n) >= 1000 || (Math.abs(n) < 0.01 && n !== 0)) {
            return n.toExponential(2);
          }
          const decimals = Math.max(
            0,
            precision - Math.floor(Math.log10(Math.abs(n) || 1)) - 1,
          );
          return n.toFixed(Math.min(decimals, 4));
        }

        class ChartRenderer {
          constructor(canvas, darkMode) {
            this.canvas = canvas;
            this.ctx = canvas.getContext("2d");
            this.darkMode = darkMode;
            this.dpr = window.devicePixelRatio || 1;
            this.margin = { top: 20, right: 20, bottom: 40, left: 60 };
            this.animProgress = 1;
            this.animStartTime = 0;
            this.hoverX = null;
            this.hoverY = null;
          }

          resize() {
            const rect = this.canvas.getBoundingClientRect();
            this.canvas.width = rect.width * this.dpr;
            this.canvas.height = rect.height * this.dpr;
            this.width = rect.width;
            this.height = rect.height;
          }

          clear() {
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.scale(this.dpr, this.dpr);
            this.ctx.fillStyle = this.darkMode ? "#1E293B" : "#FFFFFF";
            this.ctx.fillRect(0, 0, this.width, this.height);
            this.ctx.translate(0.5, 0.5);
          }

          drawGrid(xMin, xMax, yMin, yMax) {
            const ctx = this.ctx;
            const { top, right, bottom, left } = this.margin;
            const chartW = this.width - left - right;
            const chartH = this.height - top - bottom;

            const yTicks = niceTicks(yMin, yMax, 6);
            const xTicks = [];
            const xStep = Math.max(
              1,
              Math.ceil((xMax - xMin) / (chartW / 60)),
            );
            for (let x = xMin; x <= xMax; x += xStep) xTicks.push(x);

            ctx.strokeStyle = this.darkMode
              ? "rgba(255,255,255,0.06)"
              : "rgba(0,0,0,0.06)";
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);

            yTicks.forEach((t) => {
              const y = top + chartH -
                ((t - yMin) / (yMax - yMin)) * chartH;
              ctx.beginPath();
              ctx.moveTo(left, y);
              ctx.lineTo(left + chartW, y);
              ctx.stroke();
            });

            ctx.setLineDash([]);
            ctx.strokeStyle = this.darkMode
              ? "rgba(255,255,255,0.15)"
              : "rgba(0,0,0,0.15)";
            ctx.beginPath();
            ctx.moveTo(left, top);
            ctx.lineTo(left, top + chartH);
            ctx.lineTo(left + chartW, top + chartH);
            ctx.stroke();

            ctx.fillStyle = this.darkMode ? "#94A3B8" : "#64748B";
            ctx.font = "11px system-ui, -apple-system, sans-serif";
            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            yTicks.forEach((t) => {
              const y = top + chartH -
                ((t - yMin) / (yMax - yMin)) * chartH;
              ctx.fillText(formatNumber(t, 3), left - 8, y);
            });

            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            xTicks.forEach((t) => {
              const x = left + ((t - xMin) / (xMax - xMin)) * chartW;
              ctx.fillText(t.toString(), x, top + chartH + 8);
            });
          }

          drawLine(
            data,
            color,
            yMin,
            yMax,
            xMin,
            xMax,
            glow = true,
            dash = false,
          ) {
            if (data.length < 2) return;
            const ctx = this.ctx;
            const { top, right, bottom, left } = this.margin;
            const chartW = this.width - left - right;
            const chartH = this.height - top - bottom;

            const toX = (i) =>
              left + ((i - xMin) / (xMax - xMin)) * chartW;
            const toY = (v) =>
              top + chartH - ((v - yMin) / (yMax - yMin)) * chartH;

            const drawSteps = Math.min(
              data.length,
              Math.floor(data.length * this.animProgress),
            );

            if (glow) {
              ctx.strokeStyle = color.replace(")", ", 0.15)").replace(
                "rgb",
                "rgba",
              );
              ctx.lineWidth = 6;
              ctx.lineCap = "round";
              ctx.lineJoin = "round";
              ctx.setLineDash([]);
              ctx.beginPath();
              ctx.moveTo(toX(0), toY(data[0]));
              for (let i = 1; i < drawSteps; i++) {
                ctx.lineTo(toX(i), toY(data[i]));
              }
              ctx.stroke();
            }

            ctx.strokeStyle = color;
            ctx.lineWidth = 2.5;
            ctx.setLineDash(dash ? [6, 4] : []);
            ctx.beginPath();
            ctx.moveTo(toX(0), toY(data[0]));
            for (let i = 1; i < drawSteps; i++) {
              ctx.lineTo(toX(i), toY(data[i]));
            }
            ctx.stroke();
            ctx.setLineDash([]);
          }

          drawBand(lower, upper, color, yMin, yMax, xMin, xMax) {
            if (lower.length < 2) return;
            const ctx = this.ctx;
            const { top, right, bottom, left } = this.margin;
            const chartW = this.width - left - right;
            const chartH = this.height - top - bottom;

            const toX = (i) =>
              left + ((i - xMin) / (xMax - xMin)) * chartW;
            const toY = (v) =>
              top + chartH - ((v - yMin) / (yMax - yMin)) * chartH;

            const drawSteps = Math.min(
              lower.length,
              Math.floor(lower.length * this.animProgress),
            );

            const grad = ctx.createLinearGradient(
              0,
              top,
              0,
              top + chartH,
            );
            grad.addColorStop(
              0,
              color.replace(")", ", 0.15)").replace("rgb", "rgba"),
            );
            grad.addColorStop(
              1,
              color.replace(")", ", 0.05)").replace("rgb", "rgba"),
            );

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(toX(0), toY(upper[0]));
            for (let i = 1; i < drawSteps; i++) {
              const x1 = toX(i - 1), x2 = toX(i);
              const y1 = toY(upper[i - 1]), y2 = toY(upper[i]);
              const cx = (x1 + x2) / 2;
              ctx.quadraticCurveTo(x1, y1, cx, (y1 + y2) / 2);
            }
            if (drawSteps > 0) {
              ctx.lineTo(toX(drawSteps - 1), toY(upper[drawSteps - 1]));
            }
            for (let i = drawSteps - 1; i >= 0; i--) {
              const x1 = toX(i), x2 = i > 0 ? toX(i - 1) : toX(0);
              const y1 = toY(lower[i]),
                y2 = i > 0 ? toY(lower[i - 1]) : toY(lower[0]);
              const cx = (x1 + x2) / 2;
              ctx.quadraticCurveTo(x1, y1, cx, (y1 + y2) / 2);
            }
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = color.replace(")", ", 0.4)").replace(
              "rgb",
              "rgba",
            );
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(toX(0), toY(upper[0]));
            for (let i = 1; i < drawSteps; i++) {
              ctx.lineTo(toX(i), toY(upper[i]));
            }
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(toX(0), toY(lower[0]));
            for (let i = 1; i < drawSteps; i++) {
              ctx.lineTo(toX(i), toY(lower[i]));
            }
            ctx.stroke();
            ctx.setLineDash([]);
          }

          drawCrosshair(idx, value, yMin, yMax, xMin, xMax) {
            const ctx = this.ctx;
            const { top, right, bottom, left } = this.margin;
            const chartW = this.width - left - right;
            const chartH = this.height - top - bottom;

            const x = left + ((idx - xMin) / (xMax - xMin)) * chartW;
            const y = top + chartH -
              ((value - yMin) / (yMax - yMin)) * chartH;

            ctx.strokeStyle = this.darkMode
              ? "rgba(255,255,255,0.5)"
              : "rgba(0,0,0,0.5)";
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(x, top);
            ctx.lineTo(x, top + chartH);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(left, y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = COLORS[0].replace(")", ", 0.3)").replace(
              "#",
              "rgba(",
            ).replace(
              /(..)(..)(..)/,
              (m, r, g, b) =>
                parseInt(r, 16) + "," + parseInt(g, 16) + "," +
                parseInt(b, 16),
            );
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = COLORS[0];
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();
          }

          animate(duration = 600) {
            this.animProgress = 0;
            this.animStartTime = performance.now();
            const animate = (time) => {
              const elapsed = time - this.animStartTime;
              this.animProgress = Math.min(1, elapsed / duration);
              this.animProgress = 1 -
                Math.pow(1 - this.animProgress, 3);
              if (this.animProgress < 1) requestAnimationFrame(animate);
            };
            requestAnimationFrame(animate);
          }
        }

        function renderFocusChart(
          container,
          predictions,
          dim,
          darkMode,
          hoverData,
          setHoverData,
        ) {
          if (!predictions || !predictions.predictions.length) return;

          const canvas = container.querySelector("canvas") ||
            document.createElement("canvas");
          if (!canvas.parentNode) {
            canvas.className = "w-full h-full";
            container.innerHTML = "";
            container.appendChild(canvas);
          }

          const renderer = new ChartRenderer(canvas, darkMode);
          renderer.resize();

          const data = predictions.predictions.map((p) => p[dim]);
          const lower = predictions.lowerBounds.map((p) => p[dim]);
          const upper = predictions.upperBounds.map((p) => p[dim]);

          const displayData = state.performanceMode && data.length > 150
            ? lttbDownsample(data, 150)
            : data;

          let allVals = [...data, ...lower, ...upper];
          let yMin = Math.min(...allVals);
          let yMax = Math.max(...allVals);
          const yPad = (yMax - yMin) * 0.1 || 1;
          yMin -= yPad;
          yMax += yPad;

          const draw = () => {
            renderer.clear();
            renderer.drawGrid(0, data.length - 1, yMin, yMax);
            renderer.drawBand(
              lower,
              upper,
              COLORS[dim % COLORS.length],
              yMin,
              yMax,
              0,
              data.length - 1,
            );
            renderer.drawLine(
              data,
              COLORS[dim % COLORS.length],
              yMin,
              yMax,
              0,
              data.length - 1,
              true,
            );

            if (hoverData && hoverData.idx !== null) {
              renderer.drawCrosshair(
                hoverData.idx,
                data[hoverData.idx],
                yMin,
                yMax,
                0,
                data.length - 1,
              );
            }
          };

          draw();

          const handleMouse = (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const chartLeft = renderer.margin.left;
            const chartW = renderer.width - renderer.margin.left -
              renderer.margin.right;

            if (x >= chartLeft && x <= chartLeft + chartW) {
              const ratio = (x - chartLeft) / chartW;
              const idx = Math.round(ratio * (data.length - 1));
              if (idx >= 0 && idx < data.length) {
                setHoverData({
                  idx,
                  value: data[idx],
                  lower: lower[idx],
                  upper: upper[idx],
                  x: e.clientX,
                  y: e.clientY,
                });
                draw();
                return;
              }
            }
            setHoverData(null);
            draw();
          };

          canvas.onmousemove = handleMouse;
          canvas.onmouseleave = () => {
            setHoverData(null);
            draw();
          };
        }

        function renderSmallMultiples(
          container,
          predictions,
          darkMode,
          onSelect,
        ) {
          if (!predictions || !predictions.predictions.length) return;

          const nTargets = predictions.predictions[0].length;
          const cols = Math.min(
            nTargets,
            window.innerWidth < 640
              ? 2
              : window.innerWidth < 1024
              ? 3
              : 4,
          );

          let html =
            `<div class="grid gap-3" style="grid-template-columns: repeat(${cols}, 1fr)">`;

          for (let dim = 0; dim < nTargets; dim++) {
            const data = predictions.predictions.map((p) => p[dim]);
            const finalVal = data[data.length - 1];
            html += `
      <div class="bg-white dark:bg-slate-800 rounded-lg p-3 shadow-sm border border-slate-200 dark:border-slate-700 cursor-pointer hover:border-blue-400 dark:hover:border-blue-500 transition-colors" data-dim="${dim}">
        <div class="flex justify-between items-center mb-2">
          <span class="text-xs font-medium text-slate-500 dark:text-slate-400">Target ${dim}</span>
          <span class="text-sm font-semibold">${
              formatNumber(finalVal)
            }</span>
        </div>
        <canvas class="w-full h-20 mini-chart" data-dim="${dim}"></canvas>
      </div>
    `;
          }
          html += "</div>";
          container.innerHTML = html;

          container.querySelectorAll("[data-dim]").forEach((el) => {
            el.onclick = () => onSelect(parseInt(el.dataset.dim));
          });

          container.querySelectorAll(".mini-chart").forEach(
            (canvas) => {
              const dim = parseInt(canvas.dataset.dim);
              const data = predictions.predictions.map((p) => p[dim]);
              const lower = predictions.lowerBounds.map((p) => p[dim]);
              const upper = predictions.upperBounds.map((p) => p[dim]);

              const renderer = new ChartRenderer(canvas, darkMode);
              renderer.margin = {
                top: 5,
                right: 5,
                bottom: 5,
                left: 5,
              };
              renderer.resize();
              renderer.clear();

              let allVals = [...data, ...lower, ...upper];
              let yMin = Math.min(...allVals);
              let yMax = Math.max(...allVals);
              const yPad = (yMax - yMin) * 0.1 || 1;
              yMin -= yPad;
              yMax += yPad;

              renderer.drawBand(
                lower,
                upper,
                COLORS[dim % COLORS.length],
                yMin,
                yMax,
                0,
                data.length - 1,
              );
              renderer.drawLine(
                data,
                COLORS[dim % COLORS.length],
                yMin,
                yMax,
                0,
                data.length - 1,
                false,
              );
            },
          );
        }

        function renderHeatmap(container, predictions, darkMode) {
          if (!predictions || !predictions.predictions.length) return;

          const nSteps = predictions.predictions.length;
          const nTargets = predictions.predictions[0].length;

          let allVals = predictions.predictions.flat();
          const minVal = Math.min(...allVals);
          const maxVal = Math.max(...allVals);
          const range = maxVal - minVal || 1;

          const getColor = (v) => {
            const t = (v - minVal) / range;
            if (darkMode) {
              const r = Math.round(30 + t * 225);
              const g = Math.round(60 + t * 195);
              const b = Math.round(100 + t * 55);
              return `rgb(${r},${g},${b})`;
            } else {
              const r = Math.round(255 - t * 100);
              const g = Math.round(255 - t * 100);
              const b = Math.round(255 - t * 155);
              return `rgb(${r},${g},${b})`;
            }
          };

          let html =
            '<div class="overflow-auto"><table class="border-collapse text-xs">';
          html +=
            '<thead><tr><th class="sticky left-0 bg-slate-100 dark:bg-slate-800 px-2 py-1 border border-slate-300 dark:border-slate-600">Target</th>';
          for (let s = 0; s < nSteps; s++) {
            html +=
              `<th class="px-2 py-1 border border-slate-300 dark:border-slate-600">${s}</th>`;
          }
          html += "</tr></thead><tbody>";

          for (let t = 0; t < nTargets; t++) {
            html +=
              `<tr><td class="sticky left-0 bg-slate-100 dark:bg-slate-800 px-2 py-1 border border-slate-300 dark:border-slate-600 font-medium">T${t}</td>`;
            for (let s = 0; s < nSteps; s++) {
              const val = predictions.predictions[s][t];
              const color = getColor(val);
              html +=
                `<td class="px-2 py-1 border border-slate-300 dark:border-slate-600 text-center" style="background:${color}" title="Step ${s}, Target ${t}: ${
                  formatNumber(val)
                }">${formatNumber(val, 2)}</td>`;
            }
            html += "</tr>";
          }
          html += "</tbody></table></div>";

          html +=
            `<div class="mt-4 flex items-center gap-2 text-xs"><span>${
              formatNumber(minVal)
            }</span><div class="h-4 w-32 rounded" style="background: linear-gradient(to right, ${
              getColor(minVal)
            }, ${getColor(maxVal)})"></div><span>${
              formatNumber(maxVal)
            }</span></div>`;

          container.innerHTML = html;
        }

        function renderUncertaintyView(
          container,
          predictions,
          darkMode,
        ) {
          if (!predictions || !predictions.predictions.length) return;

          const canvas = document.createElement("canvas");
          canvas.className = "w-full h-64";
          container.innerHTML = "";
          container.appendChild(canvas);

          const nSteps = predictions.predictions.length;
          const nTargets = predictions.predictions[0].length;

          const avgUncertainty = [];
          for (let s = 0; s < nSteps; s++) {
            let sum = 0;
            for (let t = 0; t < nTargets; t++) {
              sum += predictions.upperBounds[s][t] -
                predictions.lowerBounds[s][t];
            }
            avgUncertainty.push(sum / nTargets);
          }

          const renderer = new ChartRenderer(canvas, darkMode);
          renderer.resize();
          renderer.clear();

          let yMin = 0;
          let yMax = Math.max(...avgUncertainty) * 1.1 || 1;

          renderer.drawGrid(0, nSteps - 1, yMin, yMax);

          const ctx = renderer.ctx;
          const { top, right, bottom, left } = renderer.margin;
          const chartW = renderer.width - left - right;
          const chartH = renderer.height - top - bottom;

          const toX = (i) => left + (i / (nSteps - 1)) * chartW;
          const toY = (v) => top + chartH - (v / yMax) * chartH;

          const grad = ctx.createLinearGradient(
            0,
            top,
            0,
            top + chartH,
          );
          grad.addColorStop(0, "rgba(239, 68, 68, 0.6)");
          grad.addColorStop(0.5, "rgba(245, 158, 11, 0.4)");
          grad.addColorStop(1, "rgba(16, 185, 129, 0.2)");

          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.moveTo(toX(0), toY(0));
          for (let i = 0; i < nSteps; i++) {
            ctx.lineTo(toX(i), toY(avgUncertainty[i]));
          }
          ctx.lineTo(toX(nSteps - 1), toY(0));
          ctx.closePath();
          ctx.fill();

          ctx.strokeStyle = "#F59E0B";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(toX(0), toY(avgUncertainty[0]));
          for (let i = 1; i < nSteps; i++) {
            ctx.lineTo(toX(i), toY(avgUncertainty[i]));
          }
          ctx.stroke();

          const confHtml = `
    <div class="mt-4 flex items-center justify-center gap-6">
      <div class="text-center">
        <div class="text-3xl font-bold ${
            predictions.confidence > 0.7
              ? "text-emerald-500"
              : predictions.confidence > 0.4
              ? "text-amber-500"
              : "text-red-500"
          }">${(predictions.confidence * 100).toFixed(1)}%</div>
        <div class="text-xs text-slate-500 dark:text-slate-400">Confidence</div>
      </div>
      <div class="text-center">
        <div class="text-lg font-semibold">${
            formatNumber(
              avgUncertainty.reduce((a, b) => a + b) /
                avgUncertainty.length,
            )
          }</div>
        <div class="text-xs text-slate-500 dark:text-slate-400">Avg Uncertainty</div>
      </div>
    </div>
  `;
          container.insertAdjacentHTML("beforeend", confHtml);
        }

        function renderBarChart(
          container,
          predictions,
          step,
          darkMode,
        ) {
          if (!predictions || !predictions.predictions.length) return;

          const nTargets = predictions.predictions[0].length;
          const values = predictions.predictions[step];
          const lower = predictions.lowerBounds[step];
          const upper = predictions.upperBounds[step];

          let html =
            `<div class="mb-4 text-sm font-medium">Step ${step} Values</div>`;
          html += '<div class="space-y-2">';

          const maxVal = Math.max(...values.map(Math.abs));

          for (let t = 0; t < nTargets; t++) {
            const width = Math.abs(values[t]) / maxVal * 100;
            const color = COLORS[t % COLORS.length];
            html += `
      <div class="flex items-center gap-2">
        <span class="w-12 text-xs text-slate-500">T${t}</span>
        <div class="flex-1 h-6 bg-slate-100 dark:bg-slate-700 rounded relative">
          <div class="h-full rounded transition-all duration-300" style="width: ${width}%; background: ${color}"></div>
          <div class="absolute inset-0 flex items-center px-2 text-xs font-medium">${
              formatNumber(values[t])
            }</div>
        </div>
        <span class="w-20 text-xs text-slate-400">[${
              formatNumber(lower[t], 2)
            }, ${formatNumber(upper[t], 2)}]</span>
      </div>
    `;
          }
          html += "</div>";
          container.innerHTML = html;
        }

        function render() {
          const app = document.getElementById("app");
          const isDark = state.theme === "dark";

          let html = `
    <div class="min-h-screen flex flex-col">
      <!-- Header -->
      <header class="bg-white dark:bg-slate-800 border-b border-slate-200 dark:border-slate-700 sticky top-0 z-40">
        <div class="max-w-7xl mx-auto px-4 py-3 flex items-center justify-between">
          <div class="flex items-center gap-3">
            <button onclick="app.toggleMenu()" class="p-2 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-lg transition-colors lg:hidden" aria-label="Toggle menu">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg>
            </button>
            <h1 class="text-lg font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">ESN Regression Studio</h1>
          </div>
          
          <div class="hidden sm:flex items-center gap-2">
            ${
            state.modelReady
              ? `
              <span class="px-2 py-1 text-xs font-medium bg-emerald-100 dark:bg-emerald-900/30 text-emerald-700 dark:text-emerald-400 rounded-full">Model Ready</span>
              ${
                state.modelSummary
                  ? `<span class="px-2 py-1 text-xs bg-slate-100 dark:bg-slate-700 rounded">R${state.modelSummary.reservoirSize}</span>`
                  : ""
              }
              ${
                state.datasetInfo
                  ? `<span class="px-2 py-1 text-xs bg-slate-100 dark:bg-slate-700 rounded">${state.datasetInfo.size} samples</span>`
                  : ""
              }
            `
              : `<span class="px-2 py-1 text-xs font-medium bg-slate-100 dark:bg-slate-700 text-slate-500 rounded-full">No Model</span>`
          }
          </div>
          
          <div class="flex items-center gap-2">
            ${
            state.modelReady && state.datasetInfo
              ? `
              <button onclick="app.runPrediction()" class="px-3 py-1.5 text-sm font-medium bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors">Predict</button>
            `
              : ""
          }
            <button onclick="app.toggleTheme()" class="p-2 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-lg transition-colors" aria-label="Toggle theme">
              ${
            isDark
              ? '<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z"/></svg>'
              : '<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"/></svg>'
          }
            </button>
          </div>
        </div>
      </header>
      
      <div class="flex-1 flex">
        <!-- Sidebar -->
        <aside class="${
            state.menuOpen ? "translate-x-0" : "-translate-x-full"
          } lg:translate-x-0 fixed lg:static inset-y-0 left-0 w-64 bg-white dark:bg-slate-800 border-r border-slate-200 dark:border-slate-700 z-50 transition-transform duration-200 overflow-y-auto scrollbar-thin">
          <nav class="p-4 space-y-6">
            <div>
              <h3 class="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-2">Model</h3>
              <div class="space-y-1">
                <button onclick="app.openModal('config')" class="w-full flex items-center gap-2 px-3 py-2 text-sm rounded-lg hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors">
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
                  Create/Config
                </button>
                <button onclick="app.openModal('saveload')" class="w-full flex items-center gap-2 px-3 py-2 text-sm rounded-lg hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors">
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"/></svg>
                  Save/Load
                </button>
                ${
            state.modelReady
              ? `<button onclick="app.resetModel()" class="w-full flex items-center gap-2 px-3 py-2 text-sm rounded-lg hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors text-amber-600 dark:text-amber-400">
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>
                  Reset
                </button>`
              : ""
          }
              </div>
            </div>
            
            <div>
              <h3 class="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-2">Data</h3>
              <div class="space-y-1">
                <button onclick="app.openModal('upload')" class="w-full flex items-center gap-2 px-3 py-2 text-sm rounded-lg hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors ${
            !state.modelReady ? "opacity-50 cursor-not-allowed" : ""
          }" ${!state.modelReady ? "disabled" : ""}>
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/></svg>
                  Upload Dataset
                </button>
                <button onclick="app.openModal('insert')" class="w-full flex items-center gap-2 px-3 py-2 text-sm rounded-lg hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors ${
            !state.modelReady ? "opacity-50 cursor-not-allowed" : ""
          }" ${!state.modelReady ? "disabled" : ""}>
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/></svg>
                  Manual Insert
                </button>
              </div>
            </div>
            
            <div>
              <h3 class="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-2">Test</h3>
              <button onclick="app.openModal('randomtest')" class="w-full flex items-center gap-2 px-3 py-2 text-sm rounded-lg bg-gradient-to-r from-purple-500 to-pink-500 text-white hover:from-purple-600 hover:to-pink-600 transition-colors">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>
                Random Test
              </button>
            </div>
            
            ${
            state.predictions
              ? `
            <div>
              <h3 class="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-2">View Mode</h3>
              <div class="space-y-1">
                ${
                ["focus", "grid", "heatmap", "uncertainty", "bar"].map(
                  (mode) => `
                  <button onclick="app.setViewMode('${mode}')" class="w-full flex items-center gap-2 px-3 py-2 text-sm rounded-lg transition-colors ${
                    state.viewMode === mode
                      ? "bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-400"
                      : "hover:bg-slate-100 dark:hover:bg-slate-700"
                  }">
                    ${mode.charAt(0).toUpperCase() + mode.slice(1)}
                  </button>
                `,
                ).join("")
              }
              </div>
            </div>`
              : ""
          }
            
            <div>
              <h3 class="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-2">Advanced</h3>
              <button onclick="app.openModal('advanced')" class="w-full flex items-center gap-2 px-3 py-2 text-sm rounded-lg hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"/></svg>
                Settings
              </button>
              <label class="flex items-center gap-2 px-3 py-2 text-sm cursor-pointer">
                <input type="checkbox" ${
            state.performanceMode ? "checked" : ""
          } onchange="app.togglePerfMode()" class="rounded border-slate-300 dark:border-slate-600 text-blue-600 focus:ring-blue-500">
                Performance Mode
              </label>
            </div>
          </nav>
        </aside>
        
        <!-- Overlay for mobile menu -->
        ${
            state.menuOpen
              ? `<div onclick="app.toggleMenu()" class="fixed inset-0 bg-black/50 z-40 lg:hidden"></div>`
              : ""
          }
        
        <!-- Main Content -->
        <main class="flex-1 p-4 lg:p-6 overflow-auto">
          ${
            !state.modelReady && !state.isLoading
              ? renderOnboarding()
              : ""
          }
          ${state.isLoading ? renderLoading() : ""}
          ${
            state.modelReady && !state.predictions && !state.isLoading
              ? renderEmptyPredictions()
              : ""
          }
          ${
            state.predictions && !state.isLoading
              ? renderVisualization()
              : ""
          }
        </main>
        
        <!-- Right Panel -->
        ${
            state.modelReady
              ? `
        <aside class="hidden xl:block w-80 bg-white dark:bg-slate-800 border-l border-slate-200 dark:border-slate-700 overflow-y-auto scrollbar-thin">
          <div class="p-4 space-y-4">
            <!-- Model Summary -->
            ${
                state.modelSummary
                  ? `
            <div class="bg-slate-50 dark:bg-slate-900/50 rounded-lg p-4">
              <h3 class="text-sm font-semibold mb-3">Model Summary</h3>
              <dl class="grid grid-cols-2 gap-2 text-xs">
                <dt class="text-slate-500">Reservoir</dt><dd class="font-medium">${state.modelSummary.reservoirSize}</dd>
                <dt class="text-slate-500">Features</dt><dd class="font-medium">${
                    state.modelSummary.nFeatures || "-"
                  }</dd>
                <dt class="text-slate-500">Targets</dt><dd class="font-medium">${
                    state.modelSummary.nTargets || "-"
                  }</dd>
                <dt class="text-slate-500">Samples</dt><dd class="font-medium">${
                    state.datasetInfo?.size || 0
                  }</dd>
                <dt class="text-slate-500">Spectral ρ</dt><dd class="font-medium">${state.modelSummary.spectralRadius}</dd>
              </dl>
            </div>`
                  : ""
              }
            
            ${
                state.trainingStats
                  ? `
            <div class="bg-slate-50 dark:bg-slate-900/50 rounded-lg p-4">
              <h3 class="text-sm font-semibold mb-3">Training Stats</h3>
              <dl class="grid grid-cols-2 gap-2 text-xs">
                <dt class="text-slate-500">Avg Loss</dt><dd class="font-medium">${
                    state.trainingStats.averageLoss?.toFixed(6) || "-"
                  }</dd>
                <dt class="text-slate-500">Gradient</dt><dd class="font-medium">${
                    state.trainingStats.gradientNorm?.toFixed(4) || "-"
                  }</dd>
              </dl>
            </div>`
                  : ""
              }
            
            ${
                state.predictions
                  ? `
            <div class="bg-slate-50 dark:bg-slate-900/50 rounded-lg p-4">
              <h3 class="text-sm font-semibold mb-3">Prediction</h3>
              <div class="mb-3">
                <label class="text-xs text-slate-500">Future Steps</label>
                <div class="flex items-center gap-2 mt-1">
                  <input type="range" min="1" max="${
                    state.modelSummary?.maxSequenceLength || 64
                  }" value="${state.futureSteps}" onchange="app.setFutureSteps(this.value)" class="flex-1">
                  <span class="text-sm font-medium w-8">${state.futureSteps}</span>
                </div>
              </div>
              <button onclick="app.runPrediction()" class="w-full px-3 py-2 text-sm font-medium bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors">Run Prediction</button>
              <dl class="mt-3 grid grid-cols-2 gap-2 text-xs">
                <dt class="text-slate-500">Confidence</dt><dd class="font-medium">${
                    (state.predictions.confidence * 100).toFixed(1)
                  }%</dd>
                <dt class="text-slate-500">Steps</dt><dd class="font-medium">${state.predictions.predictions.length}</dd>
              </dl>
            </div>`
                  : ""
              }
            
            <!-- Event Log -->
            <div class="bg-slate-50 dark:bg-slate-900/50 rounded-lg p-4">
              <h3 class="text-sm font-semibold mb-3">Event Log</h3>
              <div class="space-y-2 max-h-60 overflow-y-auto scrollbar-thin">
                ${
                state.logs.slice(0, 20).map((log) => `
                  <div class="text-xs p-2 rounded ${
                  log.level === "error"
                    ? "bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400"
                    : log.level === "success"
                    ? "bg-emerald-100 dark:bg-emerald-900/30 text-emerald-700 dark:text-emerald-400"
                    : log.level === "warning"
                    ? "bg-amber-100 dark:bg-amber-900/30 text-amber-700 dark:text-amber-400"
                    : "bg-slate-100 dark:bg-slate-800 text-slate-600 dark:text-slate-400"
                }">
                    <div class="font-medium">${log.action}</div>
                    ${
                  log.details
                    ? `<div class="text-opacity-75 mt-0.5 truncate">${log.details}</div>`
                    : ""
                }
                    <div class="text-opacity-50 mt-0.5">${log.timestamp.toLocaleTimeString()}</div>
                  </div>
                `).join("")
              }
              </div>
            </div>
          </div>
        </aside>`
              : ""
          }
      </div>
      
      <!-- Toasts -->
      <div class="fixed bottom-4 right-4 z-50 space-y-2">
        ${
            state.toasts.map((t) => `
          <div class="animate-slide-up px-4 py-3 rounded-lg shadow-lg ${
              t.type === "error"
                ? "bg-red-600 text-white"
                : t.type === "success"
                ? "bg-emerald-600 text-white"
                : t.type === "warning"
                ? "bg-amber-500 text-white"
                : "bg-slate-800 text-white"
            }">
            ${t.message}
          </div>
        `).join("")
          }
      </div>
      
      <!-- Modals -->
      ${state.activeModal ? renderModal(state.activeModal) : ""}
    </div>
  `;

          app.innerHTML = html;

          if (state.predictions && !state.isLoading) {
            setTimeout(() => initCharts(), 0);
          }
        }

        function renderOnboarding() {
          return `
    <div class="max-w-2xl mx-auto mt-8">
      <div class="text-center mb-8">
        <div class="w-20 h-20 mx-auto mb-4 rounded-2xl bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center">
          <svg class="w-10 h-10 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/></svg>
        </div>
        <h2 class="text-2xl font-bold mb-2">Welcome to ESN Regression Studio</h2>
        <p class="text-slate-500 dark:text-slate-400">Online multivariate regression and multi-horizon forecasting with Echo State Networks</p>
      </div>
      
      <div class="grid gap-4 sm:grid-cols-3">
        <button onclick="app.openModal('config')" class="p-6 bg-white dark:bg-slate-800 rounded-xl shadow-sm border border-slate-200 dark:border-slate-700 hover:border-blue-400 dark:hover:border-blue-500 transition-colors text-left">
          <div class="w-10 h-10 rounded-lg bg-blue-100 dark:bg-blue-900/30 flex items-center justify-center mb-3">
            <svg class="w-5 h-5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/></svg>
          </div>
          <h3 class="font-semibold mb-1">Start Here</h3>
          <p class="text-sm text-slate-500 dark:text-slate-400">Create a new model with recommended settings</p>
        </button>
        
        <button onclick="app.openModal('saveload')" class="p-6 bg-white dark:bg-slate-800 rounded-xl shadow-sm border border-slate-200 dark:border-slate-700 hover:border-blue-400 dark:hover:border-blue-500 transition-colors text-left">
          <div class="w-10 h-10 rounded-lg bg-purple-100 dark:bg-purple-900/30 flex items-center justify-center mb-3">
            <svg class="w-5 h-5 text-purple-600 dark:text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"/></svg>
          </div>
          <h3 class="font-semibold mb-1">Load Model</h3>
          <p class="text-sm text-slate-500 dark:text-slate-400">Load a previously saved model</p>
        </button>
        
        <button onclick="app.openModal('randomtest')" class="p-6 bg-gradient-to-br from-purple-500 to-pink-500 rounded-xl shadow-sm text-white text-left hover:from-purple-600 hover:to-pink-600 transition-colors">
          <div class="w-10 h-10 rounded-lg bg-white/20 flex items-center justify-center mb-3">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>
          </div>
          <h3 class="font-semibold mb-1">Quick Test</h3>
          <p class="text-sm text-white/80">Generate data, train, and predict instantly</p>
        </button>
      </div>
    </div>
  `;
        }

        function renderLoading() {
          return `
    <div class="flex flex-col items-center justify-center py-16">
      <div class="w-12 h-12 border-4 border-blue-200 border-t-blue-600 rounded-full animate-spin mb-4"></div>
      <p class="text-slate-500 dark:text-slate-400">${state.loadingMessage}</p>
      ${
            state.progress
              ? `
        <div class="mt-4 w-64">
          <div class="flex justify-between text-xs text-slate-500 mb-1">
            <span>${state.progress.processed} / ${state.progress.total}</span>
            <span>${state.progress.percent}%</span>
          </div>
          <div class="h-2 bg-slate-200 dark:bg-slate-700 rounded-full overflow-hidden">
            <div class="h-full bg-blue-600 transition-all duration-200" style="width: ${state.progress.percent}%"></div>
          </div>
          <button onclick="app.cancelOperation()" class="mt-3 px-4 py-1.5 text-sm text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition-colors">Cancel</button>
        </div>
      `
              : ""
          }
    </div>
  `;
        }

        function renderEmptyPredictions() {
          return `
    <div class="flex flex-col items-center justify-center py-16 text-center">
      <div class="w-16 h-16 rounded-full bg-slate-100 dark:bg-slate-800 flex items-center justify-center mb-4">
        <svg class="w-8 h-8 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/></svg>
      </div>
      <h3 class="text-lg font-semibold mb-2">Ready to Predict</h3>
      <p class="text-slate-500 dark:text-slate-400 mb-4 max-w-sm">
        ${
            state.datasetInfo
              ? `Model trained on ${state.datasetInfo.size} samples. Run a prediction to see results.`
              : "Upload training data first, then run predictions."
          }
      </p>
      <div class="flex gap-3">
        ${
            !state.datasetInfo
              ? `<button onclick="app.openModal('upload')" class="px-4 py-2 text-sm font-medium bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors">Upload Data</button>`
              : ""
          }
        ${
            state.datasetInfo
              ? `<button onclick="app.runPrediction()" class="px-4 py-2 text-sm font-medium bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors">Run Prediction</button>`
              : ""
          }
      </div>
    </div>
  `;
        }

        function renderVisualization() {
          const nTargets = state.predictions?.predictions[0]?.length ||
            1;

          return `
    <div class="space-y-4">
      <!-- Controls -->
      <div class="flex flex-wrap items-center justify-between gap-4">
        <div class="flex items-center gap-2">
          <span class="text-sm font-medium">View:</span>
          ${
            ["focus", "grid", "heatmap", "uncertainty", "bar"].map(
              (mode) => `
            <button onclick="app.setViewMode('${mode}')" class="px-3 py-1.5 text-xs font-medium rounded-lg transition-colors ${
                state.viewMode === mode
                  ? "bg-blue-600 text-white"
                  : "bg-slate-100 dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700"
              }">
              ${mode.charAt(0).toUpperCase() + mode.slice(1)}
            </button>
          `,
            ).join("")
          }
        </div>
        
        ${
            state.viewMode === "focus" && nTargets > 1
              ? `
          <select onchange="app.setSelectedDim(this.value)" class="px-3 py-1.5 text-sm bg-white dark:bg-slate-800 border border-slate-300 dark:border-slate-600 rounded-lg">
            ${
                Array(nTargets).fill(0).map((_, i) =>
                  `<option value="${i}" ${
                    state.selectedDim === i ? "selected" : ""
                  }>Target ${i}</option>`
                ).join("")
              }
          </select>
        `
              : ""
          }
        
        ${
            state.viewMode === "bar"
              ? `
          <div class="flex items-center gap-2">
            <span class="text-sm">Step:</span>
            <input type="range" min="0" max="${
                state.predictions.predictions.length - 1
              }" value="0" id="barStepSlider" onchange="app.updateBarChart()" class="w-32">
            <span id="barStepValue" class="text-sm font-medium w-6">0</span>
          </div>
        `
              : ""
          }
      </div>
      
      <!-- Chart Container -->
      <div class="bg-white dark:bg-slate-800 rounded-xl shadow-sm border border-slate-200 dark:border-slate-700 p-4">
        <div id="chartContainer" class="relative" style="height: ${
            state.viewMode === "grid"
              ? "auto"
              : state.viewMode === "heatmap"
              ? "auto"
              : "400px"
          }"></div>
      </div>
      
      <!-- Tooltip -->
      <div id="chartTooltip" class="fixed pointer-events-none z-50 hidden">
        <div class="bg-white dark:bg-slate-700 rounded-lg shadow-xl border border-slate-200 dark:border-slate-600 px-4 py-3 text-sm">
          <div class="font-semibold" id="tooltipTitle"></div>
          <div class="text-slate-500 dark:text-slate-400 mt-1" id="tooltipContent"></div>
        </div>
      </div>
    </div>
  `;
        }

        function initCharts() {
          const container = document.getElementById("chartContainer");
          if (!container || !state.predictions) return;

          const darkMode = state.theme === "dark";

          const setHoverData = (data) => {
            const tooltip = document.getElementById("chartTooltip");
            if (!data) {
              tooltip?.classList.add("hidden");
              return;
            }
            tooltip?.classList.remove("hidden");
            document.getElementById("tooltipTitle").textContent =
              `Step ${data.idx}`;
            document.getElementById("tooltipContent").innerHTML = `
      Value: <strong>${formatNumber(data.value)}</strong><br>
      Range: [${formatNumber(data.lower)}, ${formatNumber(data.upper)}]
    `;
            tooltip.style.left = (data.x + 15) + "px";
            tooltip.style.top = (data.y - 50) + "px";
          };

          switch (state.viewMode) {
            case "focus":
              renderFocusChart(
                container,
                state.predictions,
                state.selectedDim,
                darkMode,
                null,
                setHoverData,
              );
              break;
            case "grid":
              renderSmallMultiples(
                container,
                state.predictions,
                darkMode,
                (dim) => {
                  setState({ viewMode: "focus", selectedDim: dim });
                },
              );
              break;
            case "heatmap":
              renderHeatmap(container, state.predictions, darkMode);
              break;
            case "uncertainty":
              renderUncertaintyView(
                container,
                state.predictions,
                darkMode,
              );
              break;
            case "bar":
              renderBarChart(container, state.predictions, 0, darkMode);
              break;
          }
        }

        function renderModal(type) {
          let content = "";
          let title = "";

          switch (type) {
            case "config":
              title = "Model Configuration";
              content = renderConfigModal();
              break;
            case "upload":
              title = "Upload Dataset";
              content = renderUploadModal();
              break;
            case "insert":
              title = "Manual Insert";
              content = renderInsertModal();
              break;
            case "saveload":
              title = "Save / Load Model";
              content = renderSaveLoadModal();
              break;
            case "randomtest":
              title = "Random Test";
              content = renderRandomTestModal();
              break;
            case "advanced":
              title = "Advanced Settings";
              content = renderAdvancedModal();
              break;
          }

          return `
    <div class="fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop bg-black/50 animate-fade-in" onclick="if(event.target===this)app.closeModal()">
      <div class="bg-white dark:bg-slate-800 rounded-2xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden animate-slide-up" onclick="event.stopPropagation()">
        <div class="flex items-center justify-between px-6 py-4 border-b border-slate-200 dark:border-slate-700">
          <h2 class="text-lg font-semibold">${title}</h2>
          <button onclick="app.closeModal()" class="p-2 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-lg transition-colors" aria-label="Close">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
          </button>
        </div>
        <div class="px-6 py-4 overflow-y-auto max-h-[calc(90vh-120px)] scrollbar-thin">
          ${content}
        </div>
      </div>
    </div>
  `;
        }

        function renderConfigModal() {
          const config = state.modelConfig || PRESETS.startHere.config;

          return `
    <div class="space-y-6">
      <!-- Presets -->
      <div>
        <label class="block text-sm font-medium mb-2">Presets</label>
        <div class="grid grid-cols-2 sm:grid-cols-3 gap-2">
          ${
            Object.entries(PRESETS).map(([key, preset]) => `
            <button onclick="app.applyPreset('${key}')" class="p-3 text-left rounded-lg border border-slate-200 dark:border-slate-700 hover:border-blue-400 dark:hover:border-blue-500 transition-colors">
              <div class="font-medium text-sm">${preset.name}</div>
              <div class="text-xs text-slate-500 dark:text-slate-400">${preset.desc}</div>
            </button>
          `).join("")
          }
        </div>
      </div>
      
      <!-- Parameters -->
      <form id="configForm" class="space-y-4">
        <div class="grid gap-4 sm:grid-cols-2">
          ${
            renderConfigField(
              "reservoirSize",
              config.reservoirSize,
              "number",
              "32",
              "2048",
            )
          }
          ${
            renderConfigField(
              "maxSequenceLength",
              config.maxSequenceLength,
              "number",
              "8",
              "512",
            )
          }
          ${
            renderConfigField(
              "spectralRadius",
              config.spectralRadius,
              "number",
              "0.1",
              "0.99",
              "0.01",
            )
          }
          ${
            renderConfigField(
              "leakRate",
              config.leakRate,
              "number",
              "0.01",
              "1",
              "0.01",
            )
          }
          ${
            renderConfigField(
              "inputScale",
              config.inputScale,
              "number",
              "0.1",
              "5",
              "0.1",
            )
          }
          ${
            renderConfigField(
              "biasScale",
              config.biasScale,
              "number",
              "0",
              "1",
              "0.01",
            )
          }
          ${
            renderConfigField(
              "reservoirSparsity",
              config.reservoirSparsity,
              "number",
              "0",
              "0.99",
              "0.01",
            )
          }
          ${
            renderConfigField(
              "rlsLambda",
              config.rlsLambda,
              "number",
              "0.9",
              "0.9999",
              "0.0001",
            )
          }
          ${
            renderConfigField(
              "l2Lambda",
              config.l2Lambda,
              "number",
              "0",
              "0.1",
              "0.0001",
            )
          }
          ${
            renderConfigField(
              "outlierThreshold",
              config.outlierThreshold,
              "number",
              "1.5",
              "5",
              "0.1",
            )
          }
          ${
            renderConfigField(
              "uncertaintyMultiplier",
              config.uncertaintyMultiplier,
              "number",
              "1",
              "3",
              "0.01",
            )
          }
          ${
            renderConfigField(
              "seed",
              config.seed,
              "number",
              "0",
              "999999",
            )
          }
        </div>
        
        <div>
          <label class="block text-sm font-medium mb-1">Activation</label>
          <select name="activation" class="w-full px-3 py-2 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded-lg">
            <option value="tanh" ${
            config.activation === "tanh" ? "selected" : ""
          }>tanh</option>
            <option value="relu" ${
            config.activation === "relu" ? "selected" : ""
          }>relu</option>
          </select>
        </div>
        
        <div>
          <label class="block text-sm font-medium mb-1">Rollforward Mode</label>
          <select name="rollforwardMode" class="w-full px-3 py-2 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded-lg">
            <option value="holdLastX" ${
            config.rollforwardMode === "holdLastX" ? "selected" : ""
          }>Hold Last X</option>
            <option value="autoregressive" ${
            config.rollforwardMode === "autoregressive"
              ? "selected"
              : ""
          }>Autoregressive</option>
          </select>
        </div>
        
        <div class="flex items-center gap-4">
          <label class="flex items-center gap-2 text-sm cursor-pointer">
            <input type="checkbox" name="useInputInReadout" ${
            config.useInputInReadout ? "checked" : ""
          } class="rounded border-slate-300 dark:border-slate-600 text-blue-600">
            Use Input in Readout
          </label>
          <label class="flex items-center gap-2 text-sm cursor-pointer">
            <input type="checkbox" name="useBiasInReadout" ${
            config.useBiasInReadout ? "checked" : ""
          } class="rounded border-slate-300 dark:border-slate-600 text-blue-600">
            Use Bias in Readout
          </label>
        </div>
      </form>
      
      <div class="flex gap-3 pt-4 border-t border-slate-200 dark:border-slate-700">
        <button onclick="app.submitConfig()" class="flex-1 px-4 py-2 text-sm font-medium bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors">Create Model</button>
        <button onclick="app.closeModal()" class="px-4 py-2 text-sm font-medium bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 rounded-lg transition-colors">Cancel</button>
      </div>
    </div>
  `;
        }

        function renderConfigField(
          name,
          value,
          type,
          min,
          max,
          step = "1",
        ) {
          const doc = PARAM_DOCS[name] ||
            { title: name, desc: "", range: "", advice: "" };
          return `
    <div>
      <label class="block text-sm font-medium mb-1">${doc.title}
        <button type="button" onclick="app.showParamHelp('${name}')" class="ml-1 text-slate-400 hover:text-slate-600">
          <svg class="w-4 h-4 inline" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/></svg>
        </button>
      </label>
      <input type="${type}" name="${name}" value="${value}" min="${min}" max="${max}" step="${step}" class="w-full px-3 py-2 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded-lg text-sm" required>
    </div>
  `;
        }

        function renderUploadModal() {
          return `
    <div class="space-y-4">
      <div class="p-4 bg-slate-50 dark:bg-slate-900 rounded-lg text-sm">
        <p class="font-medium mb-2">Accepted Formats:</p>
        <pre class="text-xs bg-white dark:bg-slate-800 p-2 rounded overflow-x-auto">Format A: { "xCoordinates": [[...]], "yCoordinates": [[...]] }
Format B: { "samples": [{ "x": [...], "y": [...] }, ...] }</pre>
      </div>
      
      <div>
        <label class="block text-sm font-medium mb-2">Upload File</label>
        <input type="file" accept=".json" onchange="app.handleFileUpload(this)" class="w-full text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-medium file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 dark:file:bg-blue-900/30 dark:file:text-blue-400">
      </div>
      
      <div>
        <label class="block text-sm font-medium mb-2">Or Paste JSON</label>
        <textarea id="uploadJsonText" rows="6" placeholder='{"xCoordinates": [[1,2],[3,4]], "yCoordinates": [[5],[6]]}' class="w-full px-3 py-2 text-sm bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded-lg font-mono" oninput="app.validateUploadJson()"></textarea>
      </div>
      
      <div id="uploadValidation" class="hidden p-3 rounded-lg text-sm"></div>
      
      <div class="flex gap-3">
        <button id="uploadBtn" onclick="app.submitUpload()" disabled class="flex-1 px-4 py-2 text-sm font-medium bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed text-white rounded-lg transition-colors">Apply Data</button>
        <button onclick="app.closeModal()" class="px-4 py-2 text-sm font-medium bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 rounded-lg transition-colors">Cancel</button>
      </div>
    </div>
  `;
        }

        function renderInsertModal() {
          return `
    <div class="space-y-4">
      <div class="p-4 bg-slate-50 dark:bg-slate-900 rounded-lg text-sm">
        <p class="font-medium mb-2">Format:</p>
        <pre class="text-xs bg-white dark:bg-slate-800 p-2 rounded">{ "x": [feature1, feature2, ...], "y": [target1, target2, ...] }</pre>
      </div>
      
      <div>
        <label class="block text-sm font-medium mb-2">Sample JSON</label>
        <textarea id="insertJsonText" rows="4" placeholder='{"x": [1, 2, 3], "y": [4, 5]}' class="w-full px-3 py-2 text-sm bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded-lg font-mono" oninput="app.validateInsertJson()"></textarea>
      </div>
      
      <div id="insertValidation" class="hidden p-3 rounded-lg text-sm"></div>
      
      <div class="flex gap-3">
        <button id="insertBtn" onclick="app.submitInsert()" disabled class="flex-1 px-4 py-2 text-sm font-medium bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed text-white rounded-lg transition-colors">Insert & Train</button>
        <button onclick="app.closeModal()" class="px-4 py-2 text-sm font-medium bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 rounded-lg transition-colors">Cancel</button>
      </div>
    </div>
  `;
        }

        function renderSaveLoadModal() {
          return `
    <div class="space-y-6">
      <div>
        <h3 class="text-sm font-semibold mb-3">Save Model</h3>
        <button onclick="app.saveModel()" class="w-full px-4 py-2 text-sm font-medium bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg transition-colors ${
            !state.modelReady ? "opacity-50 cursor-not-allowed" : ""
          }" ${
            !state.modelReady ? "disabled" : ""
          }>Download Model File</button>
      </div>
      
      <div class="border-t border-slate-200 dark:border-slate-700 pt-6">
        <h3 class="text-sm font-semibold mb-3">Load Model</h3>
        <input type="file" accept=".json" onchange="app.handleModelLoad(this)" class="w-full text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-medium file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 dark:file:bg-blue-900/30 dark:file:text-blue-400">
      </div>
      
      <div class="border-t border-slate-200 dark:border-slate-700 pt-6">
        <h3 class="text-sm font-semibold mb-3">Local Storage</h3>
        <div class="flex gap-2">
          <button onclick="app.saveToLocalStorage()" class="flex-1 px-4 py-2 text-sm font-medium bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 rounded-lg transition-colors ${
            !state.modelReady ? "opacity-50 cursor-not-allowed" : ""
          }" ${
            !state.modelReady ? "disabled" : ""
          }>Save to Browser</button>
          <button onclick="app.loadFromLocalStorage()" class="flex-1 px-4 py-2 text-sm font-medium bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 rounded-lg transition-colors">Load from Browser</button>
        </div>
        <button onclick="app.clearLocalStorage()" class="mt-2 w-full px-4 py-2 text-sm font-medium text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition-colors">Clear All Saved Data</button>
      </div>
    </div>
  `;
        }

        function renderRandomTestModal() {
          return `
    <div class="space-y-4">
      <p class="text-sm text-slate-500 dark:text-slate-400">Generate synthetic multivariate data, train the model, and run predictions instantly.</p>
      
      <form id="randomTestForm" class="grid gap-4 sm:grid-cols-2">
        <div>
          <label class="block text-sm font-medium mb-1">Seed</label>
          <input type="number" name="seed" value="42" class="w-full px-3 py-2 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded-lg text-sm">
        </div>
        <div>
          <label class="block text-sm font-medium mb-1">Features</label>
          <input type="number" name="nFeatures" value="5" min="1" max="50" class="w-full px-3 py-2 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded-lg text-sm">
        </div>
        <div>
          <label class="block text-sm font-medium mb-1">Targets</label>
          <input type="number" name="nTargets" value="3" min="1" max="30" class="w-full px-3 py-2 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded-lg text-sm">
        </div>
        <div>
          <label class="block text-sm font-medium mb-1">Samples</label>
          <input type="number" name="nSamples" value="200" min="20" max="10000" class="w-full px-3 py-2 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded-lg text-sm">
        </div>
        <div>
          <label class="block text-sm font-medium mb-1">Difficulty (0-1)</label>
          <input type="number" name="difficulty" value="0.5" min="0" max="1" step="0.1" class="w-full px-3 py-2 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded-lg text-sm">
        </div>
        <div>
          <label class="block text-sm font-medium mb-1">Noise (0-2)</label>
          <input type="number" name="noise" value="0.3" min="0" max="2" step="0.1" class="w-full px-3 py-2 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded-lg text-sm">
        </div>
        <div>
          <label class="block text-sm font-medium mb-1">Outlier Rate (0-0.1)</label>
          <input type="number" name="outlierRate" value="0.02" min="0" max="0.1" step="0.01" class="w-full px-3 py-2 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded-lg text-sm">
        </div>
      </form>
      
      <button onclick="app.submitRandomTest()" class="w-full px-4 py-3 text-sm font-medium bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-lg transition-colors">Generate + Train + Predict</button>
    </div>
  `;
        }

        function renderAdvancedModal() {
          return `
    <div class="space-y-6">
      <div>
        <label class="block text-sm font-medium mb-2">Module URL</label>
        <input type="text" id="moduleUrlInput" value="${state.moduleUrl}" class="w-full px-3 py-2 text-sm bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded-lg font-mono">
        <p class="mt-1 text-xs text-slate-500">Default: ${DEFAULT_MODULE_URL}</p>
      </div>
      
      <button onclick="app.updateModuleUrl()" class="w-full px-4 py-2 text-sm font-medium bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors">Reinitialize Worker</button>
      
      <div class="border-t border-slate-200 dark:border-slate-700 pt-6">
        <button onclick="app.resetEverything()" class="w-full px-4 py-2 text-sm font-medium text-red-600 border border-red-300 dark:border-red-800 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition-colors">Reset Everything (Clear All Data)</button>
      </div>
    </div>
  `;
        }

        window.app = {
          toggleTheme,
          toggleMenu: () => setState({ menuOpen: !state.menuOpen }),
          openModal: (type) =>
            setState({ activeModal: type, menuOpen: false }),
          closeModal: () => setState({ activeModal: null }),
          setViewMode: (mode) => {
            setState({ viewMode: mode });
            localStorage.setItem("esn_viewMode", mode);
          },
          setSelectedDim: (dim) =>
            setState({ selectedDim: parseInt(dim) }),
          setFutureSteps: (steps) =>
            setState({ futureSteps: parseInt(steps) }),
          togglePerfMode: () => {
            setState({ performanceMode: !state.performanceMode });
            localStorage.setItem("esn_perfMode", state.performanceMode);
          },
          cancelOperation,
          resetModel,
          saveModel,

          applyPreset: (key) => {
            const form = document.getElementById("configForm");
            const config = PRESETS[key].config;
            Object.entries(config).forEach(([k, v]) => {
              const input = form.querySelector(`[name="${k}"]`);
              if (input) {
                if (input.type === "checkbox") input.checked = v;
                else input.value = v;
              }
            });
          },

          submitConfig: () => {
            const form = document.getElementById("configForm");
            const formData = new FormData(form);
            const config = {};
            for (const [key, value] of formData.entries()) {
              if (value === "on") config[key] = true;
              else if (!isNaN(parseFloat(value))) {
                config[key] = parseFloat(value);
              } else config[key] = value;
            }
            config.useInputInReadout =
              form.querySelector('[name="useInputInReadout"]').checked;
            config.useBiasInReadout =
              form.querySelector('[name="useBiasInReadout"]').checked;
            createModel(config);
          },

          showParamHelp: (name) => {
            const doc = PARAM_DOCS[name];
            if (doc) {
              toast(
                `${doc.title}: ${doc.desc}. Range: ${doc.range}. ${doc.advice}`,
                "info",
                8000,
              );
            }
          },

          handleFileUpload: async (input) => {
            if (!input.files.length) return;
            const file = input.files[0];
            const text = await file.text();
            document.getElementById("uploadJsonText").value = text;
            window.app.validateUploadJson();
          },

          validateUploadJson: async () => {
            const text =
              document.getElementById("uploadJsonText").value;
            const validation = document.getElementById(
              "uploadValidation",
            );
            const btn = document.getElementById("uploadBtn");

            if (!text.trim()) {
              validation.classList.add("hidden");
              btn.disabled = true;
              return;
            }

            const result = await validateDataInput(text);
            validation.classList.remove("hidden");

            if (result.valid) {
              validation.className =
                "p-3 rounded-lg text-sm bg-emerald-50 dark:bg-emerald-900/30 text-emerald-700 dark:text-emerald-400";
              validation.innerHTML =
                `✓ Valid: ${result.sampleCount} samples, ${result.nFeatures} features → ${result.nTargets} targets`;
              btn.disabled = false;
            } else {
              validation.className =
                "p-3 rounded-lg text-sm bg-red-50 dark:bg-red-900/30 text-red-700 dark:text-red-400";
              validation.innerHTML = `✗ ${result.error}`;
              btn.disabled = true;
            }
          },

          submitUpload: async () => {
            const text =
              document.getElementById("uploadJsonText").value;
            try {
              const data = JSON.parse(text);
              await trainData(data);
            } catch (e) {
              toast("Invalid JSON: " + e.message, "error");
            }
          },

          validateInsertJson: async () => {
            const text =
              document.getElementById("insertJsonText").value;
            const validation = document.getElementById(
              "insertValidation",
            );
            const btn = document.getElementById("insertBtn");

            if (!text.trim()) {
              validation.classList.add("hidden");
              btn.disabled = true;
              return;
            }

            const result = await validateDataInput(text);
            validation.classList.remove("hidden");

            if (result.valid) {
              validation.className =
                "p-3 rounded-lg text-sm bg-emerald-50 dark:bg-emerald-900/30 text-emerald-700 dark:text-emerald-400";
              validation.innerHTML =
                `✓ Valid: ${result.nFeatures} features → ${result.nTargets} targets`;
              btn.disabled = false;
            } else {
              validation.className =
                "p-3 rounded-lg text-sm bg-red-50 dark:bg-red-900/30 text-red-700 dark:text-red-400";
              validation.innerHTML = `✗ ${result.error}`;
              btn.disabled = true;
            }
          },

          submitInsert: async () => {
            const text =
              document.getElementById("insertJsonText").value;
            try {
              const data = JSON.parse(text);
              await trainData(data);
            } catch (e) {
              toast("Invalid JSON: " + e.message, "error");
            }
          },

          handleModelLoad: (input) => {
            if (!input.files.length) return;
            loadModelFile(input.files[0]);
          },

          saveToLocalStorage: async () => {
            try {
              const result = await sendToWorker("save", {});
              localStorage.setItem(
                "esn_savedModel",
                JSON.stringify({
                  modelState: result.modelState,
                  meta: result.meta,
                }),
              );
              toast("Model saved to browser storage", "success");
            } catch (e) {
              toast("Save failed: " + e.message, "error");
            }
          },

          loadFromLocalStorage: async () => {
            const saved = localStorage.getItem("esn_savedModel");
            if (!saved) {
              toast("No saved model found", "warning");
              return;
            }
            try {
              setState({
                isLoading: true,
                loadingMessage: "Loading model...",
              });
              await sendToWorker("load", { data: saved });
              await refreshSummary();
              setState({ modelReady: true, predictions: null });
              toast("Model loaded from browser storage", "success");
            } catch (e) {
              toast("Load failed: " + e.message, "error");
            } finally {
              setState({ isLoading: false, activeModal: null });
            }
          },

          clearLocalStorage: () => {
            localStorage.removeItem("esn_savedModel");
            toast("Saved model cleared", "info");
          },

          submitRandomTest: () => {
            const form = document.getElementById("randomTestForm");
            const formData = new FormData(form);
            const params = {};
            for (const [key, value] of formData.entries()) {
              params[key] = parseFloat(value);
            }
            runRandomTest(params);
          },

          runPrediction: () => runPrediction(state.futureSteps),

          updateModuleUrl: async () => {
            const url = document.getElementById("moduleUrlInput").value;
            setState({ moduleUrl: url });
            localStorage.setItem("esn_moduleUrl", url);
            createWorker();
            await initWorker();
            setState({ activeModal: null });
          },

          resetEverything: () => {
            if (
              confirm(
                "This will clear all data, models, and settings. Continue?",
              )
            ) {
              localStorage.clear();
              location.reload();
            }
          },

          updateBarChart: () => {
            const slider = document.getElementById("barStepSlider");
            const valueEl = document.getElementById("barStepValue");
            if (slider && valueEl) {
              valueEl.textContent = slider.value;
              const container = document.getElementById(
                "chartContainer",
              );
              renderBarChart(
                container,
                state.predictions,
                parseInt(slider.value),
                state.theme === "dark",
              );
            }
          },
        };

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && state.activeModal) {
            setState({ activeModal: null });
          }
          if (
            e.key === "m" && !e.ctrlKey && !e.metaKey &&
            document.activeElement.tagName !== "INPUT" &&
            document.activeElement.tagName !== "TEXTAREA"
          ) {
            setState({ menuOpen: !state.menuOpen });
          }
          if (
            e.key === "c" && !e.ctrlKey && !e.metaKey &&
            document.activeElement.tagName !== "INPUT" &&
            document.activeElement.tagName !== "TEXTAREA"
          ) {
            setState({ activeModal: "config" });
          }
        });

        window.addEventListener("resize", () => {
          if (state.predictions) {
            setTimeout(() => initCharts(), 150);
          }
        });

        applyTheme();
        createWorker();
        initWorker().then(() => render());
      })();
    </script>
  </body>
</html>
